local a=select;local b=string.byte;local c=string.sub;local d={'ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local function e(f,g,h)if h then local i=f/2^(g-1)%2^(h-1-(g-1)+1)return i-i%1 else local j=2^(g-1)if f%(j+j)>=j then return 1 else return 0 end end end;local function k(l)local m=1;local n;local o;local function p()local q=b(l,m,m)m=m+1;return q end;local function r()local s,t,u,v=b(l,m,m+3)m=m+4;return v*16777216+u*65536+t*256+s end;local function w()return r()*4294967296+r()end;local function x()local y=r()local z=r()local A=1;local B=e(z,1,20)*2^32+y;local C=e(z,21,31)local D=(-1)^e(z,32)if C==0 then if B==0 then return D*0 else C=1;A=0 end elseif C==2047 then if B==0 then return D*1/0 else return D*0/0 end end;return math.ldexp(D,C-1023)*(A+B/2^52)end;local function E(F)local G;if F then G=c(l,m,m+F-1)m=m+F else F=n()if F==0 then return end;G=c(l,m,m+F-1)m=m+F end;return G end;local function H()local I={}local J={}local K={}local L={Instr=I,Const=J,Proto=K,Lines={},Name=E(),FirstL=o(),LastL=o(),Upvals=p(),Args=p(),Vargs=p(),Stack=p()}if L.Name then L.Name=c(L.Name,1,-2)end;for M=1,o()do local N=r()local O=e(N,1,6)local P=d[O+1]local Q;if P then Q={Enum=O,e(N,7,14)}if P=='ABC'then Q[2]=e(N,24,32)Q[3]=e(N,15,23)elseif P=='ABx'then Q[2]=e(N,15,32)elseif P=='AsBx'then Q[2]=e(N,15,32)-131071 end else Q=N end;I[M]=Q end;for M=1,o()do local P=p()local R;if P==1 then R=p()~=0 elseif P==3 then R=x()elseif P==4 then R=c(E(),1,-2)end;J[M-1]=R end;for M=1,o()do K[M-1]=H()end;do local S=L.Lines;for M=1,o()do S[M]=r()end;for T=1,o()do E()r()r()end;for T=1,o()do E()end end;return L end;do assert(E(4)=="\27Lua","Lua bytecode expected.")assert(p()==0x51,"Only Lua 5.1 is supported.")p()p()local U=p()local V=p()if U==4 then o=r elseif U==8 then o=w else error('Integer size not supported',2)end;if V==4 then n=r elseif V==8 then n=w else error('Sizet size not supported',2)end;assert(E(3)=="\4\8\0","Unsupported bytecode target platform")end;return H()end;local function W(...)return a('#',...),{...}end;local function X(L,Y,Z)local I=L.Instr;local J=L.Const;local K=L.Proto;local function _(a0,a1)local a2=L.Name or'Code'local a3=L.Lines[a1]or'?'a0=tostring(a0):match'^.+:%s*(.+)'or a0;error(string.format('%s (%s): %s',a2,a3,a0),0)end;return function(...)local a4,a5=1,-1;local a6,a7={},a('#',...)-1;local a8={}local a9={}local aa=setmetatable({},{__index=a8,__newindex=function(T,ab,ac)if ab>a5 then a5=ab end;a8[ab]=ac end})local function ad()local Q,ae;while true do Q=I[a4]ae=Q.Enum;a4=a4+1;if ae==0 then aa[Q[1]]=aa[Q[2]]elseif ae==1 then aa[Q[1]]=J[Q[2]]elseif ae==2 then aa[Q[1]]=Q[2]~=0;if Q[3]~=0 then a4=a4+1 end elseif ae==3 then local af=aa;for M=Q[1],Q[2]do af[M]=nil end elseif ae==4 then aa[Q[1]]=Z[Q[2]]elseif ae==5 then aa[Q[1]]=Y[J[Q[2]]]elseif ae==6 then local ag=Q[3]local af=aa;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=af[Q[2]][ag]elseif ae==7 then Y[J[Q[2]]]=aa[Q[1]]elseif ae==8 then Z[Q[2]]=aa[Q[1]]elseif ae==9 then local ah,ag=Q[2],Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]][ah]=ag elseif ae==10 then aa[Q[1]]={}elseif ae==11 then local ai=Q[1]local ah=Q[2]local ag=Q[3]local af=aa;ah=af[ah]if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[ai+1]=ah;af[ai]=ah[ag]elseif ae==12 then local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=ah+ag elseif ae==13 then local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=ah-ag elseif ae==14 then local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=ah*ag elseif ae==15 then local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=ah/ag elseif ae==16 then local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=ah%ag elseif ae==17 then local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;af[Q[1]]=ah^ag elseif ae==18 then aa[Q[1]]=-aa[Q[2]]elseif ae==19 then aa[Q[1]]=not aa[Q[2]]elseif ae==20 then aa[Q[1]]=#aa[Q[2]]elseif ae==21 then local af=aa;local ah=Q[2]local aj=af[ah]for M=ah+1,Q[3]do aj=aj..af[M]end;aa[Q[1]]=aj elseif ae==22 then a4=a4+Q[2]elseif ae==23 then local ai=Q[1]~=0;local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;if ah==ag~=ai then a4=a4+1 end elseif ae==24 then local ai=Q[1]~=0;local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;if ah<ag~=ai then a4=a4+1 end elseif ae==25 then local ai=Q[1]~=0;local ah=Q[2]local ag=Q[3]local af=aa;if ah>255 then ah=J[ah-256]else ah=af[ah]end;if ag>255 then ag=J[ag-256]else ag=af[ag]end;if ah<=ag~=ai then a4=a4+1 end elseif ae==26 then if not not aa[Q[1]]==(Q[3]==0)then a4=a4+1 end elseif ae==27 then local ah=aa[Q[2]]if not not ah==(Q[3]==0)then a4=a4+1 else aa[Q[1]]=ah end elseif ae==28 then local ai=Q[1]local ah=Q[2]local ag=Q[3]local af=aa;local ak,al;local am,ad;ak={}if ah~=1 then if ah~=0 then am=ai+ah-1 else am=a5 end;ad=0;for M=ai+1,am do ad=ad+1;ak[ad]=af[M]end;am,al=W(af[ai](unpack(ak,1,am-ai)))else am,al=W(af[ai]())end;a5=ai-1;if ag~=1 then if ag~=0 then am=ai+ag-2 else am=am+ai-1 end;ad=0;for M=ai,am do ad=ad+1;af[M]=al[ad]end end elseif ae==29 then local ai=Q[1]local ah=Q[2]local af=aa;local ak,al;local am,ad;local an=0;ak={}if ah~=1 then if ah~=0 then am=ai+ah-1 else am=a5 end;ad=0;for M=ai+1,am do ad=ad+1;ak[#ak+1]=af[M]end;al={af[ai](unpack(ak,1,am-ai))}else al={af[ai]()}end;for ao in next,al do if ao>an then an=ao end end;return al,an elseif ae==30 then local ai=Q[1]local ah=Q[2]local af=aa;local ad,ap;local am;if ah==1 then return elseif ah==0 then am=a5 else am=ai+ah-2 end;ap={}ad=0;for M=ai,am do ad=ad+1;ap[ad]=af[M]end;return ap,ad elseif ae==31 then local ai=Q[1]local af=aa;local aq=af[ai+2]local ao=af[ai]+aq;af[ai]=ao;if aq>0 then if ao<=af[ai+1]then a4=a4+Q[2]af[ai+3]=ao end else if ao>=af[ai+1]then a4=a4+Q[2]af[ai+3]=ao end end elseif ae==32 then local ai=Q[1]local af=aa;af[ai]=assert(tonumber(af[ai]),'`for` initial value must be a number')af[ai+1]=assert(tonumber(af[ai+1]),'`for` limit must be a number')af[ai+2]=assert(tonumber(af[ai+2]),'`for` step must be a number')af[ai]=af[ai]-af[ai+2]a4=a4+Q[2]elseif ae==33 then local ai=Q[1]local ag=Q[3]local af=aa;local ar=ai+2;local as={af[ai](af[ai+1],af[ai+2])}for M=1,ag do aa[ar+M]=as[M]end;if af[ai+3]~=nil then af[ai+2]=af[ai+3]else a4=a4+1 end elseif ae==34 then local ai=Q[1]local ah=Q[2]local ag=Q[3]local af=aa;if ag==0 then a4=a4+1;ag=I[a4]end;local ar=(ag-1)*50;local at=af[ai]if ah==0 then ah=a5 end;for M=1,ah do at[ar+M]=af[ai+M]end elseif ae==35 then local ai=Q[1]local au={}for M=1,#a9 do local av=a9[M]for aw=0,#av do local ax=av[aw]local af=ax[1]local m=ax[2]if af==aa and m>=ai then au[m]=af[m]ax[1]=au end end end elseif ae==36 then local ay=K[Q[2]]local af=aa;local az;local aA;if ay.Upvals~=0 then az={}aA=setmetatable({},{__index=function(T,ab)local aB=az[ab]return aB[1][aB[2]]end,__newindex=function(T,ab,ac)local aB=az[ab]aB[1][aB[2]]=ac end})for M=1,ay.Upvals do local aC=I[a4]if aC.Enum==0 then az[M-1]={af,aC[2]}elseif aC.Enum==4 then az[M-1]={Z,aC[2]}end;a4=a4+1 end;a9[#a9+1]=az end;af[Q[1]]=X(ay,Y,aA)elseif ae==37 then local ai=Q[1]local ah=Q[2]local af,aD=aa,a6;a5=ai-1;for M=ai,ai+(ah>0 and ah-1 or a7)do af[M]=aD[M-ai]end end end end;local ak={...}for M=0,a7 do if M>=L.Args then a6[M-L.Args]=ak[M+1]else aa[M]=ak[M+1]end end;local ai,ah,ag=pcall(ad)if ai then if ah and ag>0 then return unpack(ah,1,ag)end;return else _(ah,a4-1)end end end;X(k(script:GetAttribute("a")),getfenv(0));
